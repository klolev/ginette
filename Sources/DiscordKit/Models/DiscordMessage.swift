import Foundation

public struct DiscordMessage: Decodable {
    /// id of the message
    public let id: String
    
    /// id of the channel the message was sent in
    public let channelID: String
    
    /// the author of this message (not guaranteed to be a valid user, see below)
    public let author: DiscordUser
    
    /// contents of the message
    public let content: String
    
    /// when this message was sent
    public let timestamp: Date
    
    /// when this message was edited (or null if never)
    public let editedTimestamp: Date?
    
    /// whether this was a TTS message
    public let tts: Bool
    
    /// whether this message mentions everyone
    public let mentionEveryone: Bool
    
    /// users specifically mentioned in the message
    public let mentions: [DiscordUser]
    
    /// roles specifically mentioned in this message
    public let mentionRoles: [String]
    
    /// channels specifically mentioned in this message
    public let mentionChannels: [DiscordChannel.Mention]?
    
    /// any attached files
    public let attachments: [Attachment]
    
    /// any embedded content
    public let embeds: [Embed]
    
    /// reactions to the message
    public let reactions: [Reaction]?
    
    /// used for validating a message was sent
    public let nonce: Nonce?
    
    /// whether this message is pinned
    public let pinned: Bool
    
    /// if the message is generated by a webhook, this is the webhook's id
    public let webhookID: String?
    
    /// type of message
    public let type: Int
    
    /// sent with Rich Presence-related chat embeds
    public let activity: Activity?
    
    /// sent with Rich Presence-related chat embeds
    public let application: DiscordApplication?
    
    /// if the message is an Interaction or application-owned webhook, this is the id of the application
    public let applicationID: String?
    
    /// data showing the source of a crosspost, channel follow add, pin, or reply message
    public let messageReference: Reference?
    
    /// message flags combined as a bitfield
    public let flags: Int?
    
    /// the message associated with the message_reference
    @Indirect
    public var referencedMessage: DiscordMessage?
    
    /// In preview. Sent if the message is sent as a result of an interaction
    public let interactionMetadata: InteractionMetadata?
    
    /// Deprecated in favor of interaction_metadata; sent if the message is a response to an interaction
    public let interaction: Interaction?
    
    /// the thread that was started from this message, includes thread member object
    public let thread: DiscordChannel?
    
    /// sent if the message contains components like buttons, action rows, or other interactive components
    public let components: [Component]?
    
    /// sent if the message contains stickers
    public let stickerItems: [StickerItem]?
    
    /// Deprecated the stickers sent with the message
    public let stickers: [DiscordSticker]?
    
    /// A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with total_message_sent on parent thread
    public let position: Int?
    
    /// data of the role subscription purchase or renewal that prompted this ROLE_SUBSCRIPTION_PURCHASE message
    public let roleSubscriptionData: RoleSubscriptionData?
    
    /// data for users, members, channels, and roles in the message's auto-populated select menus
    public let resolved: DiscordResolvedData?
    
    /// A poll!
    public let poll: DiscordPoll.Request?
    
    public init(id: String, channelID: String, author: DiscordUser, content: String, timestamp: Date, editedTimestamp: Date? = nil, tts: Bool, mentionEveryone: Bool, mentions: [DiscordUser], mentionRoles: [String], mentionChannels: [DiscordChannel.Mention]? = nil, attachments: [Attachment], embeds: [Embed], reactions: [Reaction]? = nil, nonce: Nonce? = nil, pinned: Bool, webhookID: String? = nil, type: Int, activity: Activity? = nil, application: DiscordApplication? = nil, applicationID: String? = nil, messageReference: Reference? = nil, flags: Int? = nil, referencedMessage: DiscordMessage? = nil, interactionMetadata: InteractionMetadata? = nil, interaction: Interaction? = nil, thread: DiscordChannel? = nil, components: [Component]? = nil, stickerItems: [StickerItem]? = nil, stickers: [DiscordSticker]? = nil, position: Int? = nil, roleSubscriptionData: RoleSubscriptionData? = nil, resolved: DiscordResolvedData? = nil, poll: DiscordPoll.Request? = nil) {
        self.id = id
        self.channelID = channelID
        self.author = author
        self.content = content
        self.timestamp = timestamp
        self.editedTimestamp = editedTimestamp
        self.tts = tts
        self.mentionEveryone = mentionEveryone
        self.mentions = mentions
        self.mentionRoles = mentionRoles
        self.mentionChannels = mentionChannels
        self.attachments = attachments
        self.embeds = embeds
        self.reactions = reactions
        self.nonce = nonce
        self.pinned = pinned
        self.webhookID = webhookID
        self.type = type
        self.activity = activity
        self.application = application
        self.applicationID = applicationID
        self.messageReference = messageReference
        self.flags = flags
        self.referencedMessage = referencedMessage
        self.interactionMetadata = interactionMetadata
        self.interaction = interaction
        self.thread = thread
        self.components = components
        self.stickerItems = stickerItems
        self.stickers = stickers
        self.position = position
        self.roleSubscriptionData = roleSubscriptionData
        self.resolved = resolved
        self.poll = poll
    }
    
    private enum CodingKeys: String, CodingKey {
        case id
        case channelID = "channel_id"
        case author
        case content
        case timestamp
        case editedTimestamp = "edited_timestamp"
        case tts
        case mentionEveryone = "mention_everyone"
        case mentions
        case mentionRoles = "mention_roles"
        case mentionChannels = "mention_channels"
        case attachments
        case embeds
        case reactions
        case nonce
        case pinned
        case webhookID = "webhook_id"
        case type
        case activity
        case application
        case applicationID = "application_id"
        case messageReference = "message_reference"
        case flags
        case referencedMessage = "referenced_message"
        case interactionMetadata = "interaction_metadata"
        case interaction
        case thread
        case components
        case stickerItems = "sticker_items"
        case stickers
        case position
        case roleSubscriptionData = "role_subscription_data"
        case resolved
        case poll
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        channelID = try container.decode(String.self, forKey: .channelID)
        author = try container.decode(DiscordUser.self, forKey: .author)
        content = try container.decode(String.self, forKey: .content)
        timestamp = try container.decode(Date.self, forKey: .timestamp)
        editedTimestamp = try container.decodeIfPresent(Date?.self, forKey: .editedTimestamp) ?? nil
        tts = try container.decode(Bool.self, forKey: .tts)
        mentionEveryone = try container.decode(Bool.self, forKey: .mentionEveryone)
        mentions = try container.decode([DiscordUser].self, forKey: .mentions)
        mentionRoles = try container.decode([String].self, forKey: .mentionRoles)
        mentionChannels = try container.decodeIfPresent([DiscordChannel.Mention].self, forKey: .mentionChannels)
        attachments = try container.decode([Attachment].self, forKey: .attachments)
        embeds = try container.decode([Embed].self, forKey: .embeds)
        reactions = try container.decodeIfPresent([Reaction].self, forKey: .reactions)
        
        if let nonceInt = try? container.decodeIfPresent(Int.self, forKey: .nonce) {
            nonce = .int(nonceInt)
        } else if let nonceString = try? container.decodeIfPresent(String.self, forKey: .nonce) {
            nonce = .string(nonceString)
        } else {
            nonce = nil
        }
        
        pinned = try container.decode(Bool.self, forKey: .pinned)
        webhookID = try container.decodeIfPresent(String.self, forKey: .webhookID)
        type = try container.decode(Int.self, forKey: .type)
        activity = try container.decodeIfPresent(Activity.self, forKey: .activity)
        application = try container.decodeIfPresent(DiscordApplication.self, forKey: .application)
        applicationID = try container.decodeIfPresent(String.self, forKey: .applicationID)
        messageReference = try container.decodeIfPresent(Reference.self, forKey: .messageReference)
        flags = try container.decodeIfPresent(Int.self, forKey: .flags)
        referencedMessage = try container.decodeIfPresent(DiscordMessage.self, forKey: .referencedMessage)
        interactionMetadata = try container.decodeIfPresent(InteractionMetadata.self, forKey: .interactionMetadata)
        interaction = try container.decodeIfPresent(Interaction.self, forKey: .interaction)
        thread = try container.decodeIfPresent(DiscordChannel.self, forKey: .thread)
        components = try container.decodeIfPresent([Component].self, forKey: .components)
        stickerItems = try container.decodeIfPresent([StickerItem].self, forKey: .stickerItems)
        stickers = try container.decodeIfPresent([DiscordSticker].self, forKey: .stickers)
        position = try container.decodeIfPresent(Int.self, forKey: .position)
        roleSubscriptionData = try container.decodeIfPresent(RoleSubscriptionData.self, forKey: .roleSubscriptionData)
        resolved = try container.decodeIfPresent(DiscordResolvedData.self, forKey: .resolved)
        poll = try container.decodeIfPresent(DiscordPoll.Request.self, forKey: .poll)
    }
    
    public struct Attachment: Codable {
        /// attachment id
        public let id: String
        
        /// name of file attached
        public let filename: String
        
        /// description for the file (max 1024 characters)
        public let description: String?
        
        /// the attachment's media type
        public let contentType: String?
        
        /// size of file in bytes
        public let size: Int
        
        /// source url of file
        public let url: String
        
        /// a proxied url of file
        public let proxyURL: String
        
        /// height of file (if image)
        public let height: Int?
        
        /// width of file (if image)
        public let width: Int?
        
        /// whether this attachment is ephemeral
        public let ephemeral: Bool?
        
        /// the duration of the audio file (currently for voice messages)
        public let durationSecs: Float?
        
        /// base64 encoded bytearray representing a sampled waveform (currently for voice messages)
        public let waveform: String?
        
        /// attachment flags combined as a bitfield
        public let flags: Int?
        
        public init(id: String, filename: String, size: Int, url: String, proxyURL: String, description: String? = nil, contentType: String? = nil, height: Int? = nil, width: Int? = nil, ephemeral: Bool? = nil, durationSecs: Float? = nil, waveform: String? = nil, flags: Int? = nil) {
            self.id = id
            self.filename = filename
            self.description = description
            self.contentType = contentType
            self.size = size
            self.url = url
            self.proxyURL = proxyURL
            self.height = height
            self.width = width
            self.ephemeral = ephemeral
            self.durationSecs = durationSecs
            self.waveform = waveform
            self.flags = flags
        }
        
        private enum CodingKeys: String, CodingKey {
            case id
            case filename
            case description
            case contentType = "content_type"
            case size
            case url
            case proxyURL = "proxy_url"
            case height
            case width
            case ephemeral
            case durationSecs = "duration_secs"
            case waveform
            case flags
        }
        
        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            
            try container.encode(id, forKey: .id)
            try container.encode(filename, forKey: .filename)
            try container.encodeIfPresent(description, forKey: .description)
            try container.encodeIfPresent(contentType, forKey: .contentType)
            try container.encode(size, forKey: .size)
            try container.encode(url, forKey: .url)
            try container.encode(proxyURL, forKey: .proxyURL)
            try container.encodeIfPresent(height, forKey: .height)
            try container.encodeIfPresent(width, forKey: .width)
            try container.encodeIfPresent(ephemeral, forKey: .ephemeral)
            try container.encodeIfPresent(durationSecs, forKey: .durationSecs)
            try container.encodeIfPresent(waveform, forKey: .waveform)
            try container.encodeIfPresent(flags, forKey: .flags)
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            id = try container.decode(String.self, forKey: .id)
            filename = try container.decode(String.self, forKey: .filename)
            description = try container.decodeIfPresent(String.self, forKey: .description)
            contentType = try container.decodeIfPresent(String.self, forKey: .contentType)
            size = try container.decode(Int.self, forKey: .size)
            url = try container.decode(String.self, forKey: .url)
            proxyURL = try container.decode(String.self, forKey: .proxyURL)
            height = try container.decodeIfPresent(Int?.self, forKey: .height) ?? nil
            width = try container.decodeIfPresent(Int?.self, forKey: .width) ?? nil
            ephemeral = try container.decodeIfPresent(Bool.self, forKey: .ephemeral)
            durationSecs = try container.decodeIfPresent(Float.self, forKey: .durationSecs)
            waveform = try container.decodeIfPresent(String.self, forKey: .waveform)
            flags = try container.decodeIfPresent(Int.self, forKey: .flags)
        }
    }
    
    public enum Nonce {
        case string(String)
        case int(Int)
    }

    public struct Reaction: Decodable {
        /// Total number of times this emoji has been used to react (including super reacts)
        public let count: Int
        
        /// Reaction count details object
        public let countDetails: CountDetails
        
        /// Whether the current user reacted using this emoji
        public let me: Bool
        
        /// Whether the current user super-reacted using this emoji
        public let meBurst: Bool
        
        /// emoji information
        public let emoji: DiscordEmoji
        
        /// HEX colors used for super reaction
        public let burstColors: [String]
        
        public init(count: Int, countDetails: CountDetails, me: Bool, meBurst: Bool, emoji: DiscordEmoji, burstColors: [String]) {
            self.count = count
            self.countDetails = countDetails
            self.me = me
            self.meBurst = meBurst
            self.emoji = emoji
            self.burstColors = burstColors
        }
        
        private enum CodingKeys: String, CodingKey {
            case count
            case countDetails = "count_details"
            case me
            case meBurst = "me_burst"
            case emoji
            case burstColors = "burst_colors"
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            count = try container.decode(Int.self, forKey: .count)
            countDetails = try container.decode(CountDetails.self, forKey: .countDetails)
            me = try container.decode(Bool.self, forKey: .me)
            meBurst = try container.decode(Bool.self, forKey: .meBurst)
            emoji = try container.decode(DiscordEmoji.self, forKey: .emoji)
            burstColors = try container.decode([String].self, forKey: .burstColors)
        }
        
        public struct CountDetails: Decodable {
            let burst: Int
            let normal: Int
        }
    }
    
    public struct Embed: Codable {
        /// title of embed
        public let title: String?
        
        /// type of embed (always "rich" for webhook embeds)
        public let type: String?
        
        /// description of embed
        public let description: String?
        
        /// url of embed
        public let url: String?
        
        /// timestamp of embed content
        public let timestamp: Date?
        
        /// color code of the embed
        public let color: Int?
        
        /// footer information
        public let footer: Footer?
        
        /// image information
        public let image: Image?
        
        /// thumbnail information
        public let thumbnail: Image?
        
        /// video information
        public let video: Video?
        
        /// provider information
        public let provider: Provider?
        
        /// author information
        public let author: Author?
        
        /// fields information, max of 25
        public let fields: [Field]?
        
        public init(title: String? = nil, type: String? = nil, description: String? = nil, url: String? = nil, timestamp: Date? = nil, color: Int? = nil, footer: Footer? = nil, image: Image? = nil, thumbnail: Image? = nil, video: Video? = nil, provider: Provider? = nil, author: Author? = nil, fields: [Field]? = nil) {
            self.title = title
            self.type = type
            self.description = description
            self.url = url
            self.timestamp = timestamp
            self.color = color
            self.footer = footer
            self.image = image
            self.thumbnail = thumbnail
            self.video = video
            self.provider = provider
            self.author = author
            self.fields = fields
        }
        
        private enum CodingKeys: String, CodingKey {
            case title
            case type
            case description
            case url
            case timestamp
            case color
            case footer
            case image
            case thumbnail
            case video
            case provider
            case author
            case fields
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            title = try container.decodeIfPresent(String.self, forKey: .title)
            type = try container.decodeIfPresent(String.self, forKey: .type)
            description = try container.decodeIfPresent(String.self, forKey: .description)
            url = try container.decodeIfPresent(String.self, forKey: .url)
            timestamp = try container.decodeIfPresent(Date.self, forKey: .timestamp)
            color = try container.decodeIfPresent(Int.self, forKey: .color)
            footer = try container.decodeIfPresent(Footer.self, forKey: .footer)
            image = try container.decodeIfPresent(Image.self, forKey: .image)
            thumbnail = try container.decodeIfPresent(Image.self, forKey: .thumbnail)
            video = try container.decodeIfPresent(Video.self, forKey: .video)
            provider = try container.decodeIfPresent(Provider.self, forKey: .provider)
            author = try container.decodeIfPresent(Author.self, forKey: .author)
            fields = try container.decodeIfPresent([Field].self, forKey: .fields)
        }
        
        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            
            try container.encodeIfPresent(title, forKey: .title)
            try container.encodeIfPresent(type, forKey: .type)
            try container.encodeIfPresent(description, forKey: .description)
            try container.encodeIfPresent(url, forKey: .url)
            try container.encodeIfPresent(timestamp, forKey: .timestamp)
            try container.encodeIfPresent(color, forKey: .color)
            try container.encodeIfPresent(footer, forKey: .footer)
            try container.encodeIfPresent(image, forKey: .image)
            try container.encodeIfPresent(thumbnail, forKey: .thumbnail)
            try container.encodeIfPresent(video, forKey: .video)
            try container.encodeIfPresent(provider, forKey: .provider)
            try container.encodeIfPresent(author, forKey: .author)
            try container.encodeIfPresent(fields, forKey: .fields)
        }
        
        public struct Footer: Codable {
            public let text: String
            public let iconURL: String
            public let proxyIconURL: String
            
            enum CodingKeys: String, CodingKey {
                case text
                case iconURL = "icon_url"
                case proxyIconURL = "proxy_icon_url"
            }
        }
        
        public struct Image: Codable {
            public let url: String
            public let proxyURL: String
            public let height: Int
            public let width: Int
            
            enum CodingKeys: String, CodingKey {
                case url, height, width
                case proxyURL = "proxy_url"
            }
            
            public init(url: String, proxyURL: String, height: Int, width: Int) {
                self.url = url
                self.proxyURL = proxyURL
                self.height = height
                self.width = width
            }
        }

        public struct Video: Codable {
            public let url: String
            public let height: Int
            public let width: Int
        }

        public struct Provider: Codable {
            public let name: String
            public let url: String
        }

        public struct Author: Codable {
            public let name: String
            public let url: String
            public let iconURL: String
            public let proxyIconURL: String
            
            enum CodingKeys: String, CodingKey {
                case name, url
                case iconURL = "icon_url"
                case proxyIconURL = "proxy_icon_url"
            }
        }

        public struct Field: Codable {
            public let name: String
            public let value: String
            public let inline: Bool
        }
    }
    
    public struct Activity: Decodable {
        /// type of message activity
        public let type: ActivityType
        
        /// party_id from a Rich Presence event
        public let partyID: String?
        
        public init(type: ActivityType, partyID: String? = nil) {
            self.type = type
            self.partyID = partyID
        }
        
        private enum CodingKeys: String, CodingKey {
            case type
            case partyID = "party_id"
        }
        
        public enum ActivityType: Int, Decodable {
            case join = 1
            case spectate = 2
            case listen = 3
            case joinRequest = 5
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            type = try container.decode(ActivityType.self, forKey: .type)
            partyID = try container.decodeIfPresent(String.self, forKey: .partyID)
        }
    }

    public struct Flags: OptionSet, Decodable {
        public let rawValue: Int
        
        public static let crossposted = Flags(rawValue: 1 << 0)
        public static let isCrosspost = Flags(rawValue: 1 << 1)
        public static let suppressEmbeds = Flags(rawValue: 1 << 2)
        public static let sourceMessageDeleted = Flags(rawValue: 1 << 3)
        public static let urgent = Flags(rawValue: 1 << 4)
        public static let hasThread = Flags(rawValue: 1 << 5)
        public static let ephemeral = Flags(rawValue: 1 << 6)
        public static let loading = Flags(rawValue: 1 << 7)
        public static let failedToMentionSomeRolesInThread = Flags(rawValue: 1 << 8)
        public static let suppressNotifications = Flags(rawValue: 1 << 12)
        public static let isVoiceMessage = Flags(rawValue: 1 << 13)
        
        public init(rawValue: Int) {
            self.rawValue = rawValue
        }
    }

    public struct Reference: Decodable {
        /// id of the originating message
        public let messageID: String?
        
        /// id of the originating message's channel
        public let channelID: String
        
        /// id of the originating message's guild
        public let guildID: String?
        
        /// when sending, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true
        public let failIfNotExists: Bool?
        
        public init(messageID: String? = nil, channelID: String, guildID: String? = nil, failIfNotExists: Bool? = true) {
            self.messageID = messageID
            self.channelID = channelID
            self.guildID = guildID
            self.failIfNotExists = failIfNotExists
        }
        
        private enum CodingKeys: String, CodingKey {
            case messageID = "message_id"
            case channelID = "channel_id"
            case guildID = "guild_id"
            case failIfNotExists = "fail_if_not_exists"
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            messageID = try container.decodeIfPresent(String?.self, forKey: .messageID) ?? nil
            channelID = try container.decode(String.self, forKey: .channelID)
            guildID = try container.decodeIfPresent(String?.self, forKey: .guildID) ?? nil
            failIfNotExists = try container.decodeIfPresent(Bool.self, forKey: .failIfNotExists)
        }
    }
    
    public struct InteractionMetadata: Decodable {
        /// ID of the interaction
        public let id: String
        
        /// Type of interaction
        public let type: DiscordInteraction.Request.InteractionType
        
        /// User who triggered the interaction
        public let user: DiscordUser
        
        /// IDs for installation context(s) related to an interaction
        public let authorizingIntegrationOwners: [String: [String]]
        
        /// ID of the original response message, present only on follow-up messages
        public let originalResponseMessageID: String?
        
        /// ID of the message that contained interactive component, present only on messages created from component interactions
        public let interactedMessageID: String?
        
        /// Metadata for the interaction that was used to open the modal, present only on modal submit interactions
        public let triggeringInteractionMetadata: [String: String]?
        
        public init(id: String, type: DiscordInteraction.Request.InteractionType, user: DiscordUser, authorizingIntegrationOwners: [String: [String]], originalResponseMessageID: String? = nil, interactedMessageID: String? = nil, triggeringInteractionMetadata: [String: String]? = nil) {
            self.id = id
            self.type = type
            self.user = user
            self.authorizingIntegrationOwners = authorizingIntegrationOwners
            self.originalResponseMessageID = originalResponseMessageID
            self.interactedMessageID = interactedMessageID
            self.triggeringInteractionMetadata = triggeringInteractionMetadata
        }
        
        private enum CodingKeys: String, CodingKey {
            case id
            case type
            case user
            case authorizingIntegrationOwners = "authorizing_integration_owners"
            case originalResponseMessageID = "original_response_message_id"
            case interactedMessageID = "interacted_message_id"
            case triggeringInteractionMetadata = "triggering_interaction_metadata"
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            id = try container.decode(String.self, forKey: .id)
            type = try container.decode(DiscordInteraction.Request.InteractionType.self, forKey: .type)
            user = try container.decode(DiscordUser.self, forKey: .user)
            authorizingIntegrationOwners = try container.decode([String: [String]].self, forKey: .authorizingIntegrationOwners)
            originalResponseMessageID = try container.decodeIfPresent(String?.self, forKey: .originalResponseMessageID) ?? nil
            interactedMessageID = try container.decodeIfPresent(String?.self, forKey: .interactedMessageID) ?? nil
            triggeringInteractionMetadata = try container.decodeIfPresent([String: String].self, forKey: .triggeringInteractionMetadata)
        }
    }

    public struct Interaction: Decodable {
        /// ID of the interaction
        public let id: String
        
        /// Type of interaction
        public let type: DiscordInteraction.Request.InteractionType
        
        /// Name of the application command, including subcommands and subcommand groups
        public let name: String
        
        /// User who invoked the interaction
        public let user: DiscordUser
        
        /// Member who invoked the interaction in the guild
        public let member: DiscordMember?
        
        public init(id: String, type: DiscordInteraction.Request.InteractionType, name: String, user: DiscordUser, member: DiscordMember? = nil) {
            self.id = id
            self.type = type
            self.name = name
            self.user = user
            self.member = member
        }
        
        private enum CodingKeys: String, CodingKey {
            case id
            case type
            case name
            case user
            case member
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            id = try container.decode(String.self, forKey: .id)
            type = try container.decode(DiscordInteraction.Request.InteractionType.self, forKey: .type)
            name = try container.decode(String.self, forKey: .name)
            user = try container.decode(DiscordUser.self, forKey: .user)
            member = try container.decodeIfPresent(DiscordMember.self, forKey: .member)
        }
    }
    
    public struct StickerItem: Decodable {
        /// id of the sticker
        public let id: String
        
        /// name of the sticker
        public let name: String
        
        /// type of sticker format
        public let formatType: Int
        
        public init(id: String, name: String, formatType: Int) {
            self.id = id
            self.name = name
            self.formatType = formatType
        }
        
        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case formatType = "format_type"
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            id = try container.decode(String.self, forKey: .id)
            name = try container.decode(String.self, forKey: .name)
            formatType = try container.decode(Int.self, forKey: .formatType)
        }
    }

    public struct RoleSubscriptionData: Decodable {
        /// the id of the sku and listing that the user is subscribed to
        public let roleSubscriptionListingID: String
        
        /// the name of the tier that the user is subscribed to
        public let tierName: String
        
        /// the cumulative number of months that the user has been subscribed for
        public let totalMonthsSubscribed: Int
        
        /// whether this notification is for a renewal rather than a new purchase
        public let isRenewal: Bool
        
        public init(roleSubscriptionListingID: String, tierName: String, totalMonthsSubscribed: Int, isRenewal: Bool) {
            self.roleSubscriptionListingID = roleSubscriptionListingID
            self.tierName = tierName
            self.totalMonthsSubscribed = totalMonthsSubscribed
            self.isRenewal = isRenewal
        }
        
        private enum CodingKeys: String, CodingKey {
            case roleSubscriptionListingID = "role_subscription_listing_id"
            case tierName = "tier_name"
            case totalMonthsSubscribed = "total_months_subscribed"
            case isRenewal = "is_renewal"
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            roleSubscriptionListingID = try container.decode(String.self, forKey: .roleSubscriptionListingID)
            tierName = try container.decode(String.self, forKey: .tierName)
            totalMonthsSubscribed = try container.decode(Int.self, forKey: .totalMonthsSubscribed)
            isRenewal = try container.decode(Bool.self, forKey: .isRenewal)
        }
    }

    public enum ComponentType: Int, Codable {
        case actionRow = 1
        case button = 2
        case stringSelect = 3
        case textInput = 4
        case userSelect = 5
        case roleSelect = 6
        case mentionableSelect = 7
        case channelSelect = 8
    }
    
    public enum Component: Codable {
        case actionRow([Component])
        case button(Button)
        case stringSelect(SelectMenu)
        case textInput(TextInput)
        case userSelect(SelectMenu)
        case roleSelect(SelectMenu)
        case mentionableSelect(SelectMenu)
        case channelSelect(SelectMenu)
        
        private var type: ComponentType {
            switch self {
            case .actionRow: .actionRow
            case .button: .button
            case .stringSelect: .stringSelect
            case .textInput: .textInput
            case .userSelect: .userSelect
            case .roleSelect: .roleSelect
            case .mentionableSelect: .mentionableSelect
            case .channelSelect: .channelSelect
            }
        }
        
        enum CodingKeys: String, CodingKey {
            case type
        }
        
        enum ActionRowCodingKeys: String, CodingKey {
            case components
        }
        
        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(ComponentType.self, forKey: .type)
            
            switch type {
            case .actionRow:
                let container = try decoder.container(keyedBy: ActionRowCodingKeys.self)
                let components = try container.decode([Component].self, forKey: .components)
                self = .actionRow(components)
            case .button:
                self = .button(try .init(from: decoder))
            case .stringSelect:
                self = .stringSelect(try .init(from: decoder))
            case .userSelect:
                self = .userSelect(try .init(from: decoder))
            case .mentionableSelect:
                self = .mentionableSelect(try .init(from: decoder))
            case .channelSelect:
                self = .channelSelect(try .init(from: decoder))
            case .roleSelect:
                self = .roleSelect(try .init(from: decoder))
            case .textInput:
                self = .textInput(try .init(from: decoder))
            }
        }
        
        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(type, forKey: .type)
            
            switch self {
            case .actionRow(let array):
                try array.encode(to: encoder)
            case .button(let button):
                try button.encode(to: encoder)
            case .stringSelect(let selectMenu):
                try selectMenu.encode(to: encoder)
            case .textInput(let textInput):
                try textInput.encode(to: encoder)
            case .userSelect(let selectMenu):
                try selectMenu.encode(to: encoder)
            case .roleSelect(let selectMenu):
                try selectMenu.encode(to: encoder)
            case .mentionableSelect(let selectMenu):
                try selectMenu.encode(to: encoder)
            case .channelSelect(let selectMenu):
                try selectMenu.encode(to: encoder)
            }
        }

        public struct TextInput: Codable {
            /// Developer-defined identifier for the input; max 100 characters
            public let customID: String
            
            /// The Text Input Style
            public let style: InputType
            
            /// Label for this component; max 45 characters
            public let label: String
            
            /// Minimum input length for a text input; min 0, max 4000
            public let minLength: Int?
            
            /// Maximum input length for a text input; min 1, max 4000
            public let maxLength: Int?
            
            /// Whether this component is required to be filled (defaults to true)
            public let required: Bool?
            
            /// Pre-filled value for this component; max 4000 characters
            public let value: String?
            
            /// Custom placeholder text if the input is empty; max 100 characters
            public let placeholder: String?
            
            public init(customID: String, style: InputType, label: String, minLength: Int? = nil, maxLength: Int? = nil, required: Bool? = true, value: String? = nil, placeholder: String? = nil) {
                self.customID = customID
                self.style = style
                self.label = label
                self.minLength = minLength
                self.maxLength = maxLength
                self.required = required
                self.value = value
                self.placeholder = placeholder
            }
            
            private enum CodingKeys: String, CodingKey {
                case customID = "custom_id"
                case style
                case label
                case minLength = "min_length"
                case maxLength = "max_length"
                case required
                case value
                case placeholder
            }
            
            public init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                
                customID = try container.decode(String.self, forKey: .customID)
                style = try container.decode(InputType.self, forKey: .style)
                label = try container.decode(String.self, forKey: .label)
                minLength = try container.decodeIfPresent(Int.self, forKey: .minLength)
                maxLength = try container.decodeIfPresent(Int.self, forKey: .maxLength)
                required = try container.decodeIfPresent(Bool.self, forKey: .required)
                value = try container.decodeIfPresent(String.self, forKey: .value)
                placeholder = try container.decodeIfPresent(String.self, forKey: .placeholder)
            }
            
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(customID, forKey: .customID)
                try container.encode(style, forKey: .style)
                try container.encode(label, forKey: .label)
                try container.encodeIfPresent(minLength, forKey: .minLength)
                try container.encodeIfPresent(maxLength, forKey: .maxLength)
                try container.encodeIfPresent(required, forKey: .required)
                try container.encodeIfPresent(value, forKey: .value)
                try container.encodeIfPresent(placeholder, forKey: .placeholder)
            }
            
            public enum InputType: Int, Codable {
                /// Single-line input
                case short = 1
                /// Multi-line input
                case paragraph = 2
            }
        }

        
        public struct SelectMenu: Codable {
            /// ID for the select menu; max 100 characters
            public let customID: String
            
            /// Specified choices in a select menu (only required and available for string selects (type 3); max 25
            public let options: [Option]?
            
            /// List of channel types to include in the channel select component (type 8)
            public let channelTypes: [DiscordChannel.ChannelType]?
            
            /// Placeholder text if nothing is selected; max 150 characters
            public let placeholder: String?
            
            /// List of default values for auto-populated select menu components; number of default values must be in the range defined by min_values and max_values
            public let defaultValues: [DefaultValue]?
            
            /// Minimum number of items that must be chosen (defaults to 1); min 0, max 25
            public let minValues: Int?
            
            /// Maximum number of items that can be chosen (defaults to 1); max 25
            public let maxValues: Int?
            
            /// Whether select menu is disabled (defaults to false)
            public let disabled: Bool?
            
            public init(customID: String, options: [Option]? = nil, channelTypes: [DiscordChannel.ChannelType]? = nil, placeholder: String? = nil, defaultValues: [DefaultValue]? = nil, minValues: Int? = nil, maxValues: Int? = nil, disabled: Bool? = false) {
                self.customID = customID
                self.options = options
                self.channelTypes = channelTypes
                self.placeholder = placeholder
                self.defaultValues = defaultValues
                self.minValues = minValues
                self.maxValues = maxValues
                self.disabled = disabled
            }
            
            private enum CodingKeys: String, CodingKey {
                case customID = "custom_id"
                case options
                case channelTypes = "channel_types"
                case placeholder
                case defaultValues = "default_values"
                case minValues = "min_values"
                case maxValues = "max_values"
                case disabled
            }
            
            public init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                
                customID = try container.decode(String.self, forKey: .customID)
                options = try container.decodeIfPresent([Option].self, forKey: .options)
                channelTypes = try container.decodeIfPresent([DiscordChannel.ChannelType].self, forKey: .channelTypes)
                placeholder = try container.decodeIfPresent(String.self, forKey: .placeholder)
                defaultValues = try container.decodeIfPresent([DefaultValue].self, forKey: .defaultValues)
                minValues = try container.decodeIfPresent(Int.self, forKey: .minValues)
                maxValues = try container.decodeIfPresent(Int.self, forKey: .maxValues)
                disabled = try container.decodeIfPresent(Bool.self, forKey: .disabled)
            }
            
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                
                try container.encode(customID, forKey: .customID)
                try container.encodeIfPresent(options, forKey: .options)
                try container.encodeIfPresent(channelTypes, forKey: .channelTypes)
                try container.encodeIfPresent(placeholder, forKey: .placeholder)
                try container.encodeIfPresent(defaultValues, forKey: .defaultValues)
                try container.encodeIfPresent(minValues, forKey: .minValues)
                try container.encodeIfPresent(maxValues, forKey: .maxValues)
                try container.encodeIfPresent(disabled, forKey: .disabled)
            }
            
            public struct DefaultValue: Codable {
                /// ID of a user, role, or channel
                public let id: String
                
                /// Type of value that id represents. Either "user", "role", or "channel"
                public let type: ValueType
                
                public enum ValueType: String, Codable {
                    case user, role, channel
                }
                
                public init(id: String, type: ValueType) {
                    self.id = id
                    self.type = type
                }
                
                private enum CodingKeys: String, CodingKey {
                    case id
                    case type
                }
            }
            
            public struct Option: Codable {
                /// User-facing name of the option; max 100 characters
                public let label: String
                
                /// Dev-defined value of the option; max 100 characters
                public let value: String
                
                /// Additional description of the option; max 100 characters
                public let description: String?
                
                /// id, name, and animated
                public let emoji: DiscordEmoji?
                
                /// Will show this option as selected by default
                public let `default`: Bool?
                
                public init(label: String, value: String, description: String? = nil, emoji: DiscordEmoji? = nil, default: Bool? = false) {
                    self.label = label
                    self.value = value
                    self.description = description
                    self.emoji = emoji
                    self.default = `default`
                }
                
                private enum CodingKeys: String, CodingKey {
                    case label
                    case value
                    case description
                    case emoji
                    case `default` = "default"
                }
                
                public init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    
                    label = try container.decode(String.self, forKey: .label)
                    value = try container.decode(String.self, forKey: .value)
                    description = try container.decodeIfPresent(String.self, forKey: .description)
                    emoji = try container.decodeIfPresent(DiscordEmoji.self, forKey: .emoji)
                    `default` = try container.decodeIfPresent(Bool.self, forKey: .default)
                }
                
                public func encode(to encoder: any Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)
                    try container.encode(label, forKey: .label)
                    try container.encode(value, forKey: .value)
                    try container.encodeIfPresent(description, forKey: .description)
                    try container.encodeIfPresent(emoji, forKey: .emoji)
                    try container.encodeIfPresent(`default`, forKey: .default)
                }
            }
        }
        
        public struct Button: Codable {
            /// A button style
            public let style: Style
            
            /// Text that appears on the button; max 80 characters
            public let label: String?
            
            /// name, id, and animated
            public let emoji: DiscordEmoji?
            
            /// Developer-defined identifier for the button; max 100 characters
            public let customID: String?
            
            /// URL for link-style buttons
            public let url: String?
            
            /// Whether the button is disabled (defaults to false)
            public let disabled: Bool?
            
            public enum Style: Int, Codable {
                case primary = 1
                case secondary = 2
                case success = 3
                case danger = 4
                case link = 5
            }
            
            public init(style: Style, label: String? = nil, emoji: DiscordEmoji? = nil, customID: String? = nil, url: String? = nil, disabled: Bool? = false) {
                self.style = style
                self.label = label
                self.emoji = emoji
                self.customID = customID
                self.url = url
                self.disabled = disabled
            }
            
            private enum CodingKeys: String, CodingKey {
                case style
                case label
                case emoji
                case customID = "custom_id"
                case url
                case disabled
            }
            
            public init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                
                style = try container.decode(Style.self, forKey: .style)
                label = try container.decodeIfPresent(String.self, forKey: .label)
                emoji = try container.decodeIfPresent(DiscordEmoji.self, forKey: .emoji)
                customID = try container.decodeIfPresent(String.self, forKey: .customID)
                url = try container.decodeIfPresent(String.self, forKey: .url)
                disabled = try container.decodeIfPresent(Bool.self, forKey: .disabled)
            }
            
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                
                try container.encode(style, forKey: .style)
                try container.encodeIfPresent(label, forKey: .label)
                try container.encodeIfPresent(emoji, forKey: .emoji)
                try container.encodeIfPresent(customID, forKey: .customID)
                try container.encodeIfPresent(url, forKey: .url)
                try container.encodeIfPresent(disabled, forKey: .disabled)
            }
        }
    }
}
